djsndsndfasn
asfnjdsnf
sd

snfnsakfnas
knfndkfnkd
dfnk
dsfn
ksdnf
i\fdsfs// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}
// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}// ECEN 602 Network Programming Assignment 3
// TFTP (Trivial File Transfer Protocol) Server
// Jaewon Kim   ( UIN: 424008406 )
// Rui Nie      ( UIN: 626008378 )

#include <stdio.h>          // standard buffered input/output
#include <stdlib.h>         // standard library definitions
#include <string.h>         // string operations
#include <sys/errno.h>      // system error numbers
#include <sys/types.h>      // data types
#include <sys/socket.h>     // main sockets header
#include <netinet/in.h>     // Internet address family
#include <arpa/inet.h>      // definitions for internet operations
#include <netdb.h>          // definitions for network database operations
#include <stdint.h>         // integer types
#include <signal.h>         // signals
#include <sys/time.h>       // time types

#define recv_timeout 2      // define receive TIMEOUT
#define rec_retries 10     // define receive RE-TRIES

// tftp opchoice mnemonic
enum opchoice {
     RRQ=1,
     WRQ=2,
     DATA=3,
     ACK=4,
     ERROR=5
};

// tftp transfer mode
enum mode {
     NETASCII=1,
     OCTET=2
};

// tftp message structure
typedef union {

     uint16_t opchoice;

     struct {
          uint16_t opchoice; // RRQ or WRQ
          uint8_t filename_and_mode[514];
     } request;     

     struct {
          uint16_t opchoice; // DATA
          uint16_t blk_Num;
          uint8_t data[512];
     } data;

     struct {
          uint16_t opchoice; // ACK
          uint16_t blk_Num;
     } ack;

     struct {
          uint16_t opchoice; // ERROR
          uint16_t Err_code;
          uint8_t err_string[512];
     } error;

} TFTP_Message;

// base directory
char *base_directory;

void cld_handler(int sig) {
     int status;
     wait(&status);
}



ssize_t TFTP_s_data(int s, uint16_t blk_Num, uint8_t *data,
                         ssize_t dlen, struct sockaddr_in *sock, socklen_t slen)
{    char da[512];
      int count=0; 
     TFTP_Message m;
     ssize_t c;
     int i,j;
     m.opchoice = htons(DATA);
     m.data.blk_Num = htons(blk_Num);
     memcpy(da, data, dlen);
     for(i=0;i<=511;i++){
     if(da[i]=='\r') {
             for(j=511;j>i;j--){
             da[j]=da[j-1];
         }
         da[i+1]='\0';
         count=count+1;     
        }
     if(da[i]=='\n') {
         for(j=511;j>i;j--){
         da[j]=da[j-1];
         }
         da[i]='\r';
         da[i+1]='\n';  
         i=i+1;  
         count=count+1;
         }  
     }  
     count=count+dlen+1;
    // printf("%d , %d \n %s\n", count, dlen,da);
     memcpy(m.data.data, da,count);
     da[512]='\0';
     if ((c = sendto(s, &m, 4 + dlen, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_send_ack(int s, uint16_t blk_Num,
                      struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     m.opchoice = htons(ACK);
     
     m.ack.blk_Num = htons(blk_Num);

     if ((c = sendto(s, &m, sizeof(m.ack), 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: erro sendto()");
     }

     return c;
}

ssize_t tftp_s_error(int s, int Err_code, char *err_string,
                        struct sockaddr_in *sock, socklen_t slen)
{
     TFTP_Message m;
     ssize_t c;

     if(strlen(err_string) >= 512) {
         // fprintf(stderr, "server: tftp_s_error(): ");
          return -1;
     }

     m.opchoice = htons(ERROR);
     m.error.Err_code = Err_code;
     strcpy(m.error.err_string, err_string);

     if ((c = sendto(s, &m, 4 + strlen(err_string) + 1, 0,
                     (struct sockaddr *) sock, slen)) < 0) {
          perror("server: error sendto()");
     }

     return c;
}

ssize_t tftp_rec_message(int s, TFTP_Message *m, struct sockaddr_in *sock, socklen_t *slen)
{
     ssize_t c;

     if ((c = recvfrom(s, m, sizeof(*m), 0, (struct sockaddr *) sock, slen)) < 0
          && errno != EAGAIN) {
          perror("server: error recvfrom()");
     }

     return c;
}

void tftp_handle_request(TFTP_Message *m, ssize_t len,
                         struct sockaddr_in *clientsock, socklen_t slen)
{
     int s;
     int o;
     struct protoent *pp;
     struct timeval tv;

     char *filename, *mode_s, *end;
     FILE *fd;

     int mode;
     uint16_t opchoice;

     // open new socket, on new port, to handle client request

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");
          o=1;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket()");
          o=0;
          exit(1);
     }
     tv.tv_usec = 0;
     tv.tv_sec  = recv_timeout;
     

     if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
          perror("server: setsockopt()");
          exit(1);
     }

     // parse client request

     filename = m->request.filename_and_mode;
     end = &filename[len - 2 - 1];

     if (*end != '\0') {
          printf("%s.%u: invalid filename or mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid filename or mode", clientsock, slen);
          exit(1);
     }

     mode_s = strchr(filename, '\0') + 1; 

     if (mode_s > end) {
          printf("%s.%u: transfer mode not specified\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "transfer mode not specified", clientsock, slen);
          exit(1);
     }

     if(strncmp(filename, "../", 3) == 0 || strstr(filename, "/../") != NULL ||
        (filename[0] == '/' && strncmp(filename, base_directory, strlen(base_directory)) != 0)) {
          printf("%s.%u: filename outside base directory\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "filename outside base directory", clientsock, slen);
          exit(1);
     }

     opchoice = ntohs(m->opchoice);
     fd = fopen(filename, opchoice == RRQ ? "r" : "w"); 

     if (fd == NULL) {
          perror("server: fopen()");
          o=1;
          tftp_s_error(s, errno, strerror(errno), clientsock, slen);
          exit(1);
     }

     mode = strcasecmp(mode_s, "netascii") ? NETASCII :
          strcasecmp(mode_s, "octet")    ? OCTET    :
          0;

     if (mode == 0) {
          printf("%s.%u: invalid transfer mode\n",
                 inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                 o=1;
          tftp_s_error(s, 0, "invalid transfer mode", clientsock, slen);
          exit(1);
     }

     printf("%s.%u: request : %s '%s' %s\n", 
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
            ntohs(m->opchoice) == RRQ ? "get" : "put", filename, mode_s);

     //  add netascii handling

     if (opchoice == RRQ) {
          TFTP_Message m;

          uint8_t data[512];
          ssize_t dlen, c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;
         
          while (!to_close) {

               dlen = fread(data, 1, sizeof(data), fd);
               blk_Num++;
              
               if (dlen < 512) {    // last data block to send
                    to_close = 1;
                    o=1;
               }

               for (countdown = rec_retries; countdown; countdown--) {

                    c = TFTP_s_data(s, blk_Num, data, dlen, clientsock, slen);
               
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_rec_message(s, &m, clientsock, &slen);
                    
                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, "invalid request size", clientsock, slen);
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               }

               if (!countdown) {
                    printf("server: transfer failed\n");
                    exit(1);
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != ACK)  {
                    printf("%s.%u: invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {     // the ack number is too high
                    printf("%s.%u: invalid ack number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    tftp_s_error(s, 0, "invalid ack number", clientsock, slen);
                    exit(1);
               }

          }

     }

     else if (opchoice == WRQ) {

          TFTP_Message m;

          ssize_t c;

          uint16_t blk_Num = 0;
         
          int countdown;
          int to_close = 0;

          c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
          if (c < 0) {
               printf("%s.%u: transfer killed\n",
                      inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
               exit(1);
               o=1;
          }

          while (!to_close) {

               for (countdown = rec_retries; countdown; countdown--) {

                    c = tftp_rec_message(s, &m, clientsock, &slen);

                    if (c >= 0 && c < 4) {
                         printf("%s.%u: message with invalid size received\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         tftp_s_error(s, 0, " invalid request size", clientsock, slen);
                         o=1;
                         exit(1);
                    }

                    if (c >= 4) {
                         break;
                    }

                    if (errno != EAGAIN) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

                    c = tftp_send_ack(s, blk_Num, clientsock, slen);
              
                    if (c < 0) {
                         printf("%s.%u: transfer killed\n",
                                inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                                o=1;
                         exit(1);
                    }

               }

               if (!countdown) {
                    printf("%s.%u: transfer timed out\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                           o=1;
                    exit(1);
               }

               blk_Num++;

               if (c < sizeof(m.data)) {
                    to_close = 1;
               }

               if (ntohs(m.opchoice) == ERROR)  {
                    printf("%s.%u: error message received: %u %s\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port),
                           ntohs(m.error.Err_code), m.error.err_string);
                           o=1;
                    exit(1);
               }

               if (ntohs(m.opchoice) != DATA)  {
                    printf("%s.%u: Invalid message during transfer received\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));o=1;
                           
                    tftp_s_error(s, 0, "Invalid message during transfer", clientsock, slen);
                    exit(1);
               }
              
               if (ntohs(m.ack.blk_Num) != blk_Num) {
               tftp_s_error(s, 0, "Invalid block number", clientsock, slen);
               o=1;
                    printf("%s.%u: Invalid block number received\n", 
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    
                    exit(1);
               }

               c = fwrite(m.data.data, 1, c - 4, fd);

               if (c < 0) {
                    perror("server: error fwrite()");
                    exit(1);
               }

               c = tftp_send_ack(s, blk_Num, clientsock, slen);
          
               if (c < 0) {
                    printf("%s.%u: transfer killed\n",
                           inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));
                    exit(1);
               }

          }

     }

     printf("%s.%u: transfer success\n",
            inet_ntoa(clientsock->sin_addr), ntohs(clientsock->sin_port));

     fclose(fd);
     
     close(s);

     exit(0);
}

int main(int argc, char *argv[])
{
     int s, c, count,o;
     int maxbytes=2048;
     int nextchar;
     uint16_t port = 0;
     struct protoent *pp;
     struct servent *ss;
     struct sockaddr_in server_sock;

     if (argc < 2) {
          printf("usage:\n\t%s [base directory] [port]\n", argv[0]);
          exit(1);
     }

     base_directory = argv[1];

     if (chdir(base_directory) < 0) {
          perror("server: chdir()");o=0;
          exit(1);
     }

     if (argc > 2) {
          if (sscanf(argv[2], "%hu", &port)) {
               port = htons(port);o=0;
          } else {
               fprintf(stderr, "error: invalid port number\n");o=0;
               exit(1);
          }
     } else {
          if ((ss = getservbyname("tftp", "udp")) == 0) {
               fprintf(stderr, "server: getservbyname() error\n");o=0;
               exit(1);
          }

     }

     if ((pp = getprotobyname("udp")) == 0) {
          fprintf(stderr, "server: getprotobyname() error\n");o=0;
          exit(1);
     }

     if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1) {
          perror("server: socket() error");o=0;
          exit(1);
     }

     server_sock.sin_family = AF_INET;
     server_sock.sin_addr.s_addr = htonl(INADDR_ANY);
     server_sock.sin_port = port ? port : ss->s_port;

     if (bind(s, (struct sockaddr *) &server_sock, sizeof(server_sock)) == -1) {
          perror("server: bind()");
          close(s);o=0;
          exit(1);
     }

     signal(SIGCLD, (void *) cld_handler) ;

     printf("tftp server: listening on %d\n", ntohs(server_sock.sin_port));

     while (1) {
          struct sockaddr_in clientsock;
          socklen_t slen = sizeof(clientsock);
          ssize_t len;

          TFTP_Message message;
          uint16_t opchoice;

          if ((len = tftp_rec_message(s, &message, &clientsock, &slen)) < 0) {
               continue;o=0;
          }

          if (len < 4) { 
               printf("%s.%u: request with invalid size received\n",
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port));
               tftp_s_error(s, 0, "invalid request size", &clientsock, slen);
               continue;
          }

          opchoice = ntohs(message.opchoice);

          if (opchoice == RRQ || opchoice == WRQ) {

               // spawn a child process to handle the request

               if (fork() == 0) {
                    tftp_handle_request(&message, len, &clientsock, slen);
                    exit(0);o=0;
               }

          }

          else {
               printf("%s.%u: Invalid request received: opchoice \n", 
               
                      inet_ntoa(clientsock.sin_addr), ntohs(clientsock.sin_port),
                      opchoice);o=0;
               tftp_s_error(s, 0, "Invalid opchoice", &clientsock, slen);
          }
         


     }

     close(s);

     return 0;
}
